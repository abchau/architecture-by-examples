= Architecture By Examples
:toc: auto
:toclevels: 5
:imagesdir: docs/images
:imagesoutdir: docs/images

ifdef::env-github[]
:imagesdir: docs/images/
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

This repository demonstrates different architectures by implementing the same use case.

== Rationale

* majority of existing architecture examples are often
** too bulky
** too complicated
** impractical (narrow solution of solving specific problem in specific use case)
* a dead simple use case without any burden will help understand these complicated concepts quicker and easier

== Use case

The application has

* one external *endpoint*
* one *use case*
* one *aggregate*
** one *entity*
** two *value objects*
* one database *table*

.A single subscription use case
ifdef::env-github[]
image::use-case.png[]
endif::env-github[]
ifdef::env-idea,env-vscode[]
plantuml::docs/diagrams/use-case.puml[target=use-case,format=png]
endif::env-idea,env-vscode[]

.Database table
[source,sql]
----
CREATE TABLE IF NOT EXISTS subscriptions (
	id BINARY(36) PRIMARY KEY,
	email VARCHAR(512) NOT NULL,
	status VARCHAR(256) NOT NULL,
	created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL,
	version BIGINT NOT NULL
);
----

== Usage

=== Requires

* Java 17

=== Build

* Import in your favourite IDE
* Start each project as a spring boot application individually or run `./mvnw spring-boot:run`

=== Testing

* Go to http://localhost:8080/subscribe
+
image::demo1.png[] 
* *Four* conditions can be tested
** empty input
+
image::demo2.png[] 
** not empty but invalid email format
+
image::demo3.png[] 
** correct email format
+
image::demo4.png[] 
** correct email format but duplicate
+
image::demo5.png[] 

* To verify DB records, go to:
+
[cols="h,4"]
|===
|URL|http://localhost:8080/h2-console
|JDBC URL| `jdbc:h2:mem:testdb`
|username|`sa`
|password|`password`
|===
+
image::demo6.png[] 

== Architectures

[cols="1,1,2,4,1",options=header]
|===
|#|Name|Architecture|Summary|Remarks
|1
|link:chaos/[chaos]
|Chaos Architecture
a|* Chaotic Mess
* A big ball of mud
|

|2
|link:layered/[layered]
|Layered Architecture
a|* Traditional way of implementing Layered Architecture
* poor package name
* not enough separation of concern
|

|2
|link:layered-ddd-1/[layered-ddd-1]
|Layered Architecture with Domain Driven Design Step 1 
a|* Layered with better layer names
|

|3
|link:layered-ddd-2/[layered-ddd-2]
|Layered Architecture with Domain Driven Design Step 2 
a|* Layered with better layer names
* with better separation of concern
|

|3
|link:layered-ddd-2/[layered-ddd-3]
|Layered Architecture with Domain Driven Design Step 3
a|* Layered with better layer names
* with better separation of concern
* with more examples
|

|5
|link:layered-hex/[layered-hex]
|Hexagonal Architecture (Ports and Adapters)
|
|

|7
|link:fn/[fn]
|Functional Domain Driven Design
a|* Implement DDD using Clojure
|

|===
